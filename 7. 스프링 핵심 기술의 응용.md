# 7장. 스프링 핵심 기술의 응용

## 7.1 SQL과 DAO의 분리

어떤 이유든지 SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수 밖에 없다
그러므로 SQL과 DAO를 분리해야 한다

### XML 설정을 이용한 분리

SQL을 스프링의 XML 설정파일로 빼내는 것
SQL은 문자열로 되어있으므로 이를 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입해 줄 수 있음

* **개별 SQL 프로퍼티 방식**
  * 변수와 수정자 메소드를 만들고 프로퍼티를 추가한다
* **SQL 맵 프로퍼티 방식**
  * SQL이 많을 경우에 사용
  * SQL을 하나의 컬렉션에 담는 방법 사용
  * 하나의 맵 변수와 수정자 메소드를 만들고 프로퍼티에 맵을 추가한다



### SQL 제공 서비스

SQL과 DI 설정정보가 섞여있으면 보기에도 지저분하고 관리하기에도 좋지 않음
SQL의 경우 꼭 XML에 담아 둘 필요도 없다
또 다양한 곳에서 SQL을 읽어오게 될 수도 있다
그러므로 독립적인 SQL 제공 서비스가 필요하다

* **SQL 서비스 인터페이스**

  ```java
  public interface SqlService {
    String getSql(String key) throws SqlRetrievalFailureExceptions;
  }
  ```

* **스프링 설정을 사용하는 단순 SQL 서비스**
  * 코드와 설정만 놓고 보자면 앞서 사용했던 방법과 별반 다를게 없어 보일 수 있다
  * 하지만 이제 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 된다
  * 구체적인 구현 방법과 기술에 상관 없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다



## 7.2 인터페이스 분리와 자기참조 빈

### XML 파일 매핑

검색용 키와 SQL 문장 두 가지를 담을 수 있는 간단한 XML 문서를 설계해보고, 이 XML 파일에서 SQL을 읽어뒀다가 DAO에게 제공해주는 SQL 서비스 구현 클래스를 만들어 본다

* **JAXB**
  * XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해줌
  * XML 문서의 구조를 정의한 스키마를 이용해서 매핑힐 오브젝트의 클래스까지 자동으로 만들어주는 컴파일러도 제공
  * 스키마 컴파일러를 통해 자동생성된 오브젝트에는 매핑정보가 애노테이션으로 담겨있음
* **언마샬링**
  * 언마샬링 : XML 문서를 읽어서 자바의 오브젝트로 변환하는 것
  * 마샬링 : 바인딩 오브젝트를 XML 문서로 변환하는 것
  * 직렬화 : 자바 오브젝트를 바이트 스트림으로 바꾸는 것



### 빈의 초기화 작업

* 개선해야 할 점
  * 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 잡ㄱ업을 다루는 것은 좋지 않음
    * 초기 상태를 가진 오브젝트를 만들어 놓고 별도의 초기화 메소드를 사용하는 방법이 바람직 
  * 읽어들일 파일의 위치와 이름이 코드에 고정되어 있다는 점
    * 외부에서 DI로 설정해줄 수 있게 만들어야 함
* @PostConstruct
  * 스프링은 이 애노테이션을 빈 오브젝트의 초기화 메소드를 지정하는데 사용
  * 초기화 작업을 수할 메소드에 @PostConstruct 를 부여해주면 스프링은 XmlSqlService 클래스로 등록된 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤에 @PostConstruct가 붙은 메소드를 자동으로 실행해줌
  * 생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행된다는 면에서 매우 유용



### 변화를 위한 준비: 인터페이스 분리

* **책임에 따른 인터페이스 정의**
  * 분리 가능한 관심사 구분
    * SQL 정보를 외부의 리소스로부터 읽어오는 것
    * 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 것
    * 서비스를 위해 한 번 가져오 SQL을 필요에 따라 수정할 수 있게 하는 것
      * 전략 패턴을 적용해 별도의 오브젝트 분리 필요
* **SqlRegistry 인터페이스**
  * sql 등록
  * sql 검색
* **SqlReader 인터페이스**
  * sql 읽어오기



### 자기참조 빈으로 시작하기

* **다중 인터페이스 구현과 간접 참조**
  * 세분화된 책임을 정의한 인터페이스들을 구현한다
  * 같은 클래스의 코드이지만 책임이 다른 코드는 직접 접근 하지 않고 인터페이스를 통해 간접적으로 접근한다
* **자기참조 빈 설정**
  * ref 항목에 자기 자신을 넣어 준다



### 디폴트 의존관계

* **디폴트 의존관계를 갖는 빈 만들기**
  * 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는 것을 고려해볼 필요가 있다
  * 디폴트 의존관계 : 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의존관계를 말함
    * 디폴트로 젛용하고 싶은 의존 오브젝트를 생성자에 넣어줌
    * 빈 설정이 없어짐



## 7.3 서비스 추상화 적용

개선과제 

1. 자바에는 JAXB 외에도 다양한 매핑기술이 있다. 손쉽게 바꿔사용이 가능해야 한다
2. XML 피일을 좀더 다양한 솟 에서 가져올 수 있게 만든다. 임의의 클래스 패스나 파일시스템 상의 절대위치 또는 HTTP 프로토콜을 통해 원격에서 가져오도록



### OXM 추상화 서비스

* OXM ( Object-XML Mapping ) : XML과 자바오브젝트를 매핑해서 상호 변환해주는 기술

* 자주 사용되는 매핑 기술

  * Castor XML

  * JiBX

  * XmlBeans

  * Xstream

* **OXM 서비스 인터페이스**
  * 스프링이 제공하는 OXM 추상화 서비스 인터페이스
    * Marshaller
    * Unmarshaller

### OXM 서비스 추상화 적용

* **멤버 클래스를 참조하는 통합 클래스**
  * OxmSqlService는 SqlReader 타입의 의존 오브젝트를 사용하되 이를 스태틱 멤버 클래스로 내장하고 자신만이 사용할 수 있도록 한다
    * 내장된 SqlReader 구현을 외부에서 사용하지 못하도록 제한하고 스스로 최적화된 구조로 만들어 두는 것
    * 밖에서 볼때 하나의 오브젝으로 보이나 내부에서는 의존관계를 가진 두 개의 오브젝트가 결합되어 사용됨
    * 유연성은 떨어지나 내부적으로 낮은 결합도와 응집도가 높은 구현이 가능
  * 위와 같은 구조를 사용하는 이유
    * OXM을 이용하는 서비스 구조로 최적화하기 위해서
    * SqlService를 위해 등록할 빈이 자꾸 늘어남
      자꾸 늘어나는 빈과 비슷한 DI 구조가 불편할 수 있음
    * 빈의 개수를 줄이고 설정방법을 단순하게 하는 방법에는 BaseSqlService를 확장해서 디폴트 설정을 하는 방법도 존재
      하지만 이는 디폴트로 내부에서 만드는 오브젝트의 프로퍼티는 외부에서 지정해주기가 힘듬
* **위임을 이용한 BaseSqlService의 재사용**
  * BaseSqlService와 OxmSqlService에 중복되는 코드가 존재한다
    만약 이 코드가 양이 많고 변경이 자주 일어난다면 어떨까? 코드 중복제거 방법이 필요하다
  * 위임구조를 이용
    * 두개의 클래스를 하나로 묶음
    * OxmSqlReader를 OxmSqlService에 내장하고 있는 것과 같은 방법 사용

### 리소스 추상화

지금까지 만든 OxmSqlReader와 XmlSqlReader에는 문제점이 있다.
UserDao 클래스와 같은 클래스패스에 존재하는 파일만 읽어올 수 있다는 점이다.
자바에는 다양한 위치에 존재하는 리소스에 대해 단일화된 접근 인터페이스를 제공해주는 클래스가 없다.

이를 서비스 추상화를 이용해 만들어 보면 어떨까?

* **리소스**
  * 스프링은 자바의 일관성 없는 리소스 접근 API를 추상화해서 Resource라는 추상화 인터페이스를 정의
  * 리소스는 스프링에서 빈이 아닌 값으로 취급됨
  * 서비스를 제공해주는 것이 아니라 단순히 정보를 가진 값으로 지정
  * 추상화를 적용하는 방법에 문제가 있음
    * 빈으로 지정 불가
    * 외부에서 지정해도 property의 value 애트리뷰트를 넣는 방법 뿐 --> 문자열 only
* **리소스 로더**
  * 접두어를 이용해 Resource 오브젝트를 선언하는 방법 존재
    * 문자열 안에 리소스의 종류와 리소스의 위치를 함께 표현하게 해주는 것
  * 문자열로 정의된 리소스를 실제 Resource 타입 오브젝트로 변환해주는 ResourceLoader 제공
    * ResourceLoader도 인터페이스
  * 접두어의 예
    * file:
    * classpath:
    * none
    * http:
  * 대표적인 예
    * 스프링의 애플리케이션 컨텍스트
      * 스프링 설정정보가 담긴 xml 도 리소스 로더를 이용해 Resource로 읽어옴
    * 빈의 프로퍼티 값을 변환할 때
    * 스프링이 제공하는 빈으로 등록 가능한 클래스에 파일을 지정해주는 프로퍼티는 거의 모두 리소스 타입



## 7.4 인터페이스 상속을 통한 안전한 기능확장

서버가 운영 중인 상태에서 서버를 재시작하지 않고 긴급하게 애플리케이션이 사용 중인 SQL을 변경해야 하는 경우 어떻게 해야 할까?

### DI와 기능의 확장

* **DI를 의식히는 설계**
  * DI를 적용하려면 커다란 오브젝트 하나만 존재해서는 안됨
  * 최소한 두 개 이상의, 의존관계를 가지고 서로 협력해서 일하는 오브젝트가 필요
  * 그래서 적절한 책임에 따라 오브젝트 분리가 필요함
  * 항상 의존 오브젝트는 자유롭게 확장될 수 있다는 점을 염두에 둬야함
  * DI란 미래를 프로그래밍 하는 것
* **DI와 인터페이스 프로그래밍**
  * DI 다운 DI란 두 개의 오브젝트가 인터페이스를 통해 느슨하게 연결되는 것
  * 인터페이스를 사용하는 이유
    1. 다형성을 얻기 위해서
    2. 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확히 해줄 수 있으므로
       * **인터페이스 분리 원칙** : 오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클리이언트기 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있음

### 인터페이스 상속

* 인터페이스를 여러개 만드는 대신 기존 인터페이스를 상속을 통해 확장하는 방법도 있다



## 7.5 DI를 이용해 다양한 구현 방법 적용하기

실제 구현을 해볼 차례이다.
운영중인 시스템에서 사용하는 정보를 실시간으로 변경하는 작업을 만들 때 고려해야 할 사항은 동시성 문제이다.
읽기 전용에서는 상관 없으나 수정은 다르다.

### ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리

* ConcurrentHashMap은 동기화된 해시 데이타 조작에 최적화 되어있다.
  * ConcurrentHashMap은 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 아예 사용하지 않음
  * 어느정도 안전하면서 성능이 보장되는 동기화된 HashMap으로 이용하기 적당
* **수정 가능 SQL 레지스트리 테스트 작성**
  * 수정 가능 SQL 레지스트리 구현

### 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기

저장되는 데이터의 양이 많아지거 잦은 조회와 변경이 일어나는 환경이라면 내징형 DB를 이용하여 SQL을 저장하고 수장하는 것을 추천한다.
내장형 DB는 애플리케이션에 내장되어 애플리케이션과 함께 시작되고 종료되는 DB를 말한다.
데이터는 메모리에 저장되기 때문에 IO로 인해 발생하는 부하가 적어서 성능이 뛰어나다.
안정적인 방법으로 등록, 수정, 검색이 가능하고 최적화된 락킹, 격리수준, 트랜잭션을 적용할 수 있다.

* **스프링의 내징향 DB 지원 기능**

  * 자바에서 지원하는 내장형 DB
    * Derby
    * HSQL
    * H2
  * 위 모두 JDBC 드라이버를 제공하고 표준 DB와 호환되는 기능을 제공
  * 하지만 기존의 Datasource와 DAO를 사용하던 모델 그대로 사용하는 건 좋은 방법이 아니다.
    * 외부 DB 생성과 다른 초기화 작업이 별도로 필요하기 때문
  * 스프링은 내장형 DB를 초기화하는 작업을 지원하는 편리한 내장형 DB 빌더 제공

* **내장형 DB 빌더 학습 테스트**

  * 내장형 DB는 애플리케이션을 통해 DB가 시작될 때마다 매번 테이블을 새롭게 생성한다;

    * 따라서 지속적으로 사용 가능한 테이블 생성 SQL 스크립트를 준비해둰야 함
    * 초기 데이터도 미리 준비해뒀다가 DB가 시작될 때 실행되게 해야 함

  * 스프링이 제공하는 내장형 DB 빌더는 EmbeddedDatabaseBuilder이다.

    ```java
    new EmbeddedDatabaseBuilder()
      	.setType(내장형 DB 종류)
        .addScript(초기화에 사용할 DB 스크립트의 리소스)
        ...
        .build();
    ```

  * EmbeddedDatabaseBuilder 빌더가 최종적으로 만들어주는 오브젝트는 DataSource를 상속한 EmbeddedDatabase 타입이다.

* **내장형 DB를 이용한 SqlRegistry 만들기**
  * UpdatableSqlRegistry 테스트 코드의 재사용



### 트랜잭션 적용

EmbeddedSqlRegistry에 사용된 SimpleJdbcTemplate는 트랜잭션이 적용되어 있지 않다.
그렇다면 Map을 통해 여러 개의 데이터를 업데이트 하는 도중 에러가 발생한다면 롤백이 되지 않고 그냥 작업이 중단될 것이다.
내장형 DB는 트렌젝션 적용이 쉽다.

* **다중 SQL 수정에 대한 트랜잭션 테스트**
  * 코드를 이용한 트랜잭션 적용



## 7.6 스프링 3.1의 DI

###### 스프링이 지지하고 지원하는 객체지향적인 코드의 장점인 유연성과 확작성을 스프링 스스로가 충실하게 지켜왔기 때문에 많은 변화 속에서 스프링이 꾸준히 호환성을 지키고 안정된 기술을 유지해올 수 있었다.

스프링 프레임워크 자체도 DI 원칙을 충실하게 따라서 만들어졌기 때문에 기존 설계와 코드에 영향을 주지 않고도 꾸준히 새로운 기능을 추가하고 확장해 나가는 일이 가능했다.

* **자바 언어의 변화와 스프링**

  자바 언어의 변화로 인한 스프링 프레임워크의 변화

  * **애노테이션의 메타정보 활용**

    애노테이션은 자바 코드가 실행되는 데 직접 참여하지 못한다
    상속, 오버라이딩도 불가능하다
    동작하는 코드도 넣을 수 없다

    리플렉션 API를 통해 애노테이션 내의 설정된 값을 가져와서 참고하는 방법이 전부다

    **그럼에도 불구하고 애노테이션의 활용이 늘어난 이유는 무엇일까?**

    * 애플리케이션의 핵심 로직을 담은 자바코드와 이를 지원하는 IoC 방식의 프레임워크, 그리고 프레임워크가 참조하는 메타정보라는 세 가지로 구성하는 방식에 잘 어울리기 때문이다
    * 앞서 DaoFactory를 XML로 전환한 적이 있다.
      XML은 프레임워크가 할일이 좀 더 많아지지만, 작성이 편하고 빌드 과정이 필요 없으며, AOP를 위해 빈 생성과 관계설정을 재구성하는 경우를 고려하면 자바 코드보다 유리하다
    * **애노테이션은 이를 하나를 클래스 선언 위에 넣는것 하나로 여러가지 정보를 얻을 수 있다.**
      타입, 부여된 클래스의 패키지, 클래스 이름, 접근 제한자, 상속한 클래스나 구현 인터페이스, 클래스의 필드나 메소드 구성 등
    * 리팩토링에서도 XML과 애노테이션에 많은 차이점이 드러난다
      클래스의 패키지 변경이나 클래스의 이름 변경시 XML은 변경이 안전하지 못하다 (직접 변경해야 하는 듯)
    * 애노테이션에도 단점은 존재한다
      XML은 어느 환경에서나 손쉽게 편집이 가능하고 빌드를 다시할 필요가 없으나
      애노테이션은 매번 재 컴파일해줘야 한다
      고객에게 납품하는 경우 소스코드를 제공해야 한다는 점도 있다

  * **정책과 관례를 이용한 프로그래밍**

    * 애노테이션을 제대로 활용하려면 관례화된 정책을 기억하고 코드를 작성해야한다.
    * 정책은 코드에서는 그 내용을 찾을 수 없다
      애노테이션에 명시적인 정보를 넣지 않아 코드는 간결해지지만 정책을 기엇 못하거나 잘못 알고 있을 경우 의도한 대로 동작하지 않는 코드가 만들어 질 수 있다
    * 스프링은 애노테이션으로 메타정보를 작성하고, 미리 정해진 정책과 관례를 활용해서 간결한 코드에 많은 내용을 담을 수 있는 방식을 적극 도입하고 있다

##### 앞으로 스프링 3.1의 DI 스타일로 6단계에 걸쳐 변경을 진행해 보자

### 1. 자바코드를 이용한 빈 설정

첫번쨰로 애노테이션과 자바 코드로 XML을 대체한다

* XML을 더 이상 사용하지 않게 하는 것이 최종 목표

  1. DI 설정정보를 담을 클래스 생성
     평범한 자바 클래스 +` @Configuration`

  2. XML 대신 클래스를 테스트 DI 컨텍스트 정보로 사용하도록 변경
     `@ContextConfiguration(locations="xml 위치")` 를
     `@ContextConfiguration(classes="클래스 이름.class")` 로 변경

  3. 클래스의 DI 설정정보에서 XML의 설정 정보를 가져옴
     XML의 설정정보를 다 옮겨오면 삭제
     `@ImportResource("xml 위치")`

  4. `<context:annotation-config />` 제거
     @Configuration이 붙은 설정 클래스가 직접 @PostConstruct 애노테이션을 처리하는 빈 후처리기는 등록해준다
     @PostConstruct : 이를 붙인 메소드가 빈이 초기화 된 후에 자동으로 설정한 후처리기를 실행한다

  5. `<bean>` 전환
     `<bean>`은  @Bean이 붙은 public 메소드로 변환해 준다

     자바코드에서 XML에서 정의한 빈을 참조하는 방법에는 두가지가 있다

     * @Autowired : 필드에 빈을 주입 받을 때 사용, 필드의 타입을 기준으로 빈을 검색
     * @Resource : 필드에 빈을 주입 받을 때 사용, 필드의 이름을 기준으로 빈을 검색

     ```xml
     <bean id="dataSource"
           class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
     			<property name="driverClass" value="com.mysql.jdbc.Driver" />
       		<property name="url" value="~~" />
       		<property name="username" value="spring" />
       		<property name="password" value="book" />
     </bean>
     ```

     ```java
     @Bean
     public DataSource dataSource() {
       	SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
       	dataSource.setDirverClass(Driver.class);
         dataSource.setUrl("~~");
        	dataSource.setUsername("spring");
        	dataSource.setPassword("book");
         
         return dataSource;
     }
     ```

  6. 전용 태그 전환
     `<jdbc:embedded-database>` 같은 경우는 EmbeddedDatabaseBuilder를 이용해서 변환 가능

     `<tx:annotaion-driven>` 같은 경우는 네 가지의 클래스를 빈으로 등록해준다
     하지만 이를 모두 빈으로 설정 할 필요는 없다 위와 같은 특변한 목적을 위해서 만들어진, 내부적으로 복잡한 로우 레벨의 빈을 등록해주는 전용태그에 대응되는 애노테이션을 제공하기 떄문

     바로 @EnableTransactionManagement 이다. 이를 클래스에 붙여주면 된다

### 2. 빈 스캐닝과 자동 와이어링

* **Autowired를 이용한 자동와이어링**
  * 스프링은 @Autowired가 붙은 수정자 메소드가 있으면 파라미터 타입을 보고 주입 가능한 타입의 빈을 모두 찾는다
    주입 가능한 타입의 빈이 하나라면 수정자 메소드를 호출해서 넣어주고
    주입 가능한 타입의 빈이 두개 이상 나오면 그 중에서 프로퍼티와 동일한 이름의 빈이 있는지 찾아서 일치하면 넣어준다
  * @Autowired가 있다고 수정자 메소드를 함부로 지워서는 안된다
    스프링과 무관하게 직접 오브젝트를 생성하고 다른 오브젝트를 주입해서 테스트하는 순수한 단위테스트를 하는 경우 수정자 메소드가 필요하기 때문
* **@Component를 이용한 자동 빈 등록**
  * 클래스에 부여된다
  * @Component("원하는 이름")가 붙은 클래스를 **빈 스캐너를 통해 자동으로 빈으로 등록된다**
    정확히는 @Component 또는 @Component를 메타 애노테이션으로 갖고 있는 애노테이션이 붙은 클래스
  * `@ComponentScan(basePackages="springbook.user")`을 통해서 특정 패키지 아래에서만 찾도록 기준을 정해준다
  * 애노테이션을 메타 애노테이션으로 붙여주면 상속과 비슷하게 동작한다
    @Component를 메타 애노테이션으로 갖는 애노테이션의 예시는 다음과 같다
    @Repository, @Service 등

### 3. 컨텍스트 분리와 @import

* **테스트용 컨텍스트 분리**
* **@Import**
  * 자바 클래스로된 설정 정보를 가져올 때는 @Import를 사용한다
    AppContext에 추가하여 이를 설절 클래스로 사용하는 경우 @Import한 설정클래스도 함께 적용되도록 한다

### 4. 프로파일

스프링 3.1은 환경에 따라서 빈 설정 정보가 달라져야 하는 경우에 파일을 여러 개로 쪼개고 조합하는 등의 번거로운 방법 대신 간단히 설정정보를 구성할 수 있는 방법을 제공한다

* **@Profile과 @ActiveProfile**

  * @Profile
    * 클래스 단위로 설정
    * `@Profile("test")` : 클래스 레벨에 부여하고 프로파일 이름을 넣어주면 됨
    * 프로파일이 지정되지 않은 빈 설정은 default 프로파일로 항상 취급되며 항상 적용된다
    * 프로파일이 붙은 설정 클래스는 현재 컨테이너의 활성 프로파일 목록에 자신의 프로파일 이름이 들어 있지 않으면 무시된다
      활성 프로파일이란, 스프링 컨테이너를 실행할 떄 추가로 지정해주는 속성
  * @ActiveProfile
    * 활성 프로파일로 지정하려면 이 애노테이션을 사용
    * 동작 시킬 클래스에 `@ActiveProfile("test")` 애노테이션을 사용한다

* **중첩 클래스를 이용한 프로파일 적용**

  프로파일에 따라 분리했던 설정 정보를 하나의 파일로 모아보자
  프로파일이 지정된 독립된 설정 클래스의 구조는 그대로 유지한 채로 소스코드의 위치만 통합

  * 스태틱 중첩 클래스 이용
    * @Import에 지정했던 프로파일 클래스를 제거할 수 있음
  * 하지만 빈 설정파일이 많고 코드가 많다면 하나로 모으는건 그닥 좋은 일이 아닐 수 있음

### 5. 프로퍼티 소스

* **@PropertySource**
  * 프로퍼티의 값으로 들어갈 정보는 XML 대신 자바의 프로퍼티 파일 포맷을 이용한다
  * xx.properties 파일에 내용을 저장
  * 스프링 3.1은 빈 설정 작업에 필요한 프로퍼티 정보를 컨테이너가 관리하고 제공해 준다
    * 컨테이너가 프로퍼티 값을 가져오는 대상을 프로퍼티 소스라고 한다
      환경 변수, 프로퍼티 파일, 리소스 등
    * `@PropertySource("파일위치")` 애노테이션을 이용해 프로퍼티 소스를 등록
    * 등록된 프로퍼티의 값은 `Environment 타입`의 환경 오브젝트에 저장된다
      `@Autowired`를 통해 필드에 주입 받을 수 있음
      `getProperty("프로퍼티 이름")`를 통해서 값을 가져올 수 있음
* **PropertySourcesPlaceholderConfigure**
  * 프로퍼티 값을 직접 DI 받는 방법이 존재
    * @Value 애노테이션 사용
      `@Value("${db.username}") String username;`
    * ${db.username} : 치환자
      프로퍼티 소스로부터 값을 주입받을 수 있도록 하는 방식
  * 치환자를 이용해 프로퍼티 값을 필드에 주입하려면 특별한 빈이 필요하다
    * `PropertySourcesPlaceholderConfigure`를 빈으로 정의해줘야 함
    * static 필수
    * 빈 팩토리 후처리기로 사용되는 빈을 정의해주는 것

### 6. 빈 설정의 재사용과 @Enable*

SQL 서비스를 재사용 가능한 독립적인 모듈로 만들어 보자

* **빈 설정자**
  * 문제
    * SQL 매핑 리소스의 디폴트 위치가 문제
    * SQL 매핑파일 이름이나 위치한 패키지가 달라 질 수 있음
      클래스 패스가 아닌 서블릿 컨텍스트나 파일 시스템, HTTP를 통한 리소스 일 가능성 있음
  * 해결
    * 기본적인 DI 방법을 이용
    * 인터페이스를 통해 기능 분리
    * 구현체 생성 후 빈으로 등록
    * @Autowired로 값 주입
  * 또 다른 방법
    * AppContext가 직접 SqlMapConfig 인터페이스를 상속받아서 구현하게 하는 것
    * 다른 구현체를 만들 필요가 없음
    * 자동으로 빈으로써 주입 가능해짐
* **@Enabel* 애노테이션**
  * @Import도 @Component처럼 대체 가능하다
    * @Import를 메타 애노테이션으로 넣고 새로운 애노테이션을 만들어 주면 된다
  * 앞서 사용한 @EnableTransactionManagement가 그 예이다
  * 사용에 대한 의미가 깔끔하게 들어난다는 장점이 있다
  * 



