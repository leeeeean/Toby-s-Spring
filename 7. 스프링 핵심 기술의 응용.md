# 7장. 스프링 핵심 기술의 응용

## 7.1 SQL과 DAO의 분리

어떤 이유든지 SQL 변경이 필요한 상황이 발생하면 SQL을 담고 있는 DAO 코드가 수정될 수 밖에 없다
그러므로 SQL과 DAO를 분리해야 한다

### XML 설정을 이용한 분리

SQL을 스프링의 XML 설정파일로 빼내는 것
SQL은 문자열로 되어있으므로 이를 설정파일에 프로퍼티 값으로 정의해서 DAO에 주입해 줄 수 있음

* **개별 SQL 프로퍼티 방식**
  * 변수와 수정자 메소드를 만들고 프로퍼티를 추가한다
* **SQL 맵 프로퍼티 방식**
  * SQL이 많을 경우에 사용
  * SQL을 하나의 컬렉션에 담는 방법 사용
  * 하나의 맵 변수와 수정자 메소드를 만들고 프로퍼티에 맵을 추가한다



### SQL 제공 서비스

SQL과 DI 설정정보가 섞여있으면 보기에도 지저분하고 관리하기에도 좋지 않음
SQL의 경우 꼭 XML에 담아 둘 필요도 없다
또 다양한 곳에서 SQL을 읽어오게 될 수도 있다
그러므로 독립적인 SQL 제공 서비스가 필요하다

* **SQL 서비스 인터페이스**

  ```java
  public interface SqlService {
    String getSql(String key) throws SqlRetrievalFailureExceptions;
  }
  ```

* **스프링 설정을 사용하는 단순 SQL 서비스**
  * 코드와 설정만 놓고 보자면 앞서 사용했던 방법과 별반 다를게 없어 보일 수 있다
  * 하지만 이제 모든 DAO는 SQL을 어디에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 된다
  * 구체적인 구현 방법과 기술에 상관 없이 SqlService 인터페이스 타입의 빈을 DI 받아서 필요한 SQL을 가져다 쓰기만 하면 된다



## 7.2 인터페이스 분리와 자기참조 빈

### XML 파일 매핑

검색용 키와 SQL 문장 두 가지를 담을 수 있는 간단한 XML 문서를 설계해보고, 이 XML 파일에서 SQL을 읽어뒀다가 DAO에게 제공해주는 SQL 서비스 구현 클래스를 만들어 본다

* **JAXB**
  * XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매핑해줌
  * XML 문서의 구조를 정의한 스키마를 이용해서 매핑힐 오브젝트의 클래스까지 자동으로 만들어주는 컴파일러도 제공
  * 스키마 컴파일러를 통해 자동생성된 오브젝트에는 매핑정보가 애노테이션으로 담겨있음
* **언마샬링**
  * 언마샬링 : XML 문서를 읽어서 자바의 오브젝트로 변환하는 것
  * 마샬링 : 바인딩 오브젝트를 XML 문서로 변환하는 것
  * 직렬화 : 자바 오브젝트를 바이트 스트림으로 바꾸는 것



### 빈의 초기화 작업

* 개선해야 할 점
  * 생성자에서 예외가 발생할 수도 있는 복잡한 초기화 잡ㄱ업을 다루는 것은 좋지 않음
    * 초기 상태를 가진 오브젝트를 만들어 놓고 별도의 초기화 메소드를 사용하는 방법이 바람직 
  * 읽어들일 파일의 위치와 이름이 코드에 고정되어 있다는 점
    * 외부에서 DI로 설정해줄 수 있게 만들어야 함
* @PostConstruct
  * 스프링은 이 애노테이션을 빈 오브젝트의 초기화 메소드를 지정하는데 사용
  * 초기화 작업을 수할 메소드에 @PostConstruct 를 부여해주면 스프링은 XmlSqlService 클래스로 등록된 빈의 오브젝트를 생성하고 DI 작업을 마친 뒤에 @PostConstruct가 붙은 메소드를 자동으로 실행해줌
  * 생성자와는 달리 프로퍼티까지 모두 준비된 후에 실행된다는 면에서 매우 유용



### 변화를 위한 준비: 인터페이스 분리

* **책임에 따른 인터페이스 정의**
  * 분리 가능한 관심사 구분
    * SQL 정보를 외부의 리소스로부터 읽어오는 것
    * 읽어온 SQL을 보관해두고 있다가 필요할 때 제공해주는 것
    * 서비스를 위해 한 번 가져오 SQL을 필요에 따라 수정할 수 있게 하는 것
      * 전략 패턴을 적용해 별도의 오브젝트 분리 필요
* **SqlRegistry 인터페이스**
  * sql 등록
  * sql 검색
* **SqlReader 인터페이스**
  * sql 읽어오기



### 자기참조 빈으로 시작하기

* **다중 인터페이스 구현과 간접 참조**
  * 세분화된 책임을 정의한 인터페이스들을 구현한다
  * 같은 클래스의 코드이지만 책임이 다른 코드는 직접 접근 하지 않고 인터페이스를 통해 간접적으로 접근한다
* **자기참조 빈 설정**
  * ref 항목에 자기 자신을 넣어 준다



### 디폴트 의존관계

* **디폴트 의존관계를 갖는 빈 만들기**
  * 특정 의존 오브젝트가 대부분의 환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 사용될 가능성이 있다면, 디폴트 의존관계를 갖는 빈을 만드는 것을 고려해볼 필요가 있다
  * 디폴트 의존관계 : 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의존관계를 말함
    * 디폴트로 젛용하고 싶은 의존 오브젝트를 생성자에 넣어줌
    * 빈 설정이 없어짐



## 7.3 서비스 추상화 적용

개선과제 

1. 자바에는 JAXB 외에도 다양한 매핑기술이 있다. 손쉽게 바꿔사용이 가능해야 한다
2. XML 피일을 좀더 다양한 솟 에서 가져올 수 있게 만든다. 임의의 클래스 패스나 파일시스템 상의 절대위치 또는 HTTP 프로토콜을 통해 원격에서 가져오도록



### OXM 추상화 서비스

* OXM ( Object-XML Mapping ) : XML과 자바오브젝트를 매핑해서 상호 변환해주는 기술

* 자주 사용되는 매핑 기술

  * Castor XML

  * JiBX

  * XmlBeans

  * Xstream

* **OXM 서비스 인터페이스**
  * 스프링이 제공하는 OXM 추상화 서비스 인터페이스
    * Marshaller
    * Unmarshaller

### OXM 서비스 추상화 적용

* **멤버 클래스를 참조하는 통합 클래스**
  * OxmSqlService는 SqlReader 타입의 의존 오브젝트를 사용하되 이를 스태틱 멤버 클래스로 내장하고 자신만이 사용할 수 있도록 한다
    * 내장된 SqlReader 구현을 외부에서 사용하지 못하도록 제한하고 스스로 최적화된 구조로 만들어 두는 것
    * 밖에서 볼때 하나의 오브젝으로 보이나 내부에서는 의존관계를 가진 두 개의 오브젝트가 결합되어 사용됨
    * 유연성은 떨어지나 내부적으로 낮은 결합도와 응집도가 높은 구현이 가능
  * 위와 같은 구조를 사용하는 이유
    * OXM을 이용하는 서비스 구조로 최적화하기 위해서
    * SqlService를 위해 등록할 빈이 자꾸 늘어남
      자꾸 늘어나는 빈과 비슷한 DI 구조가 불편할 수 있음
    * 빈의 개수를 줄이고 설정방법을 단순하게 하는 방법에는 BaseSqlService를 확장해서 디폴트 설정을 하는 방법도 존재
      하지만 이는 디폴트로 내부에서 만드는 오브젝트의 프로퍼티는 외부에서 지정해주기가 힘듬
* **위임을 이용한 BaseSqlService의 재사용**
  * BaseSqlService와 OxmSqlService에 중복되는 코드가 존재한다
    만약 이 코드가 양이 많고 변경이 자주 일어난다면 어떨까? 코드 중복제거 방법이 필요하다
  * 위임구조를 이용
    * 두개의 클래스를 하나로 묶음
    * OxmSqlReader를 OxmSqlService에 내장하고 있는 것과 같은 방법 사용

### 리소스 추상화

지금까지 만든 OxmSqlReader와 XmlSqlReader에는 문제점이 있다.
UserDao 클래스와 같은 클래스패스에 존재하는 파일만 읽어올 수 있다는 점이다.
자바에는 다양한 위치에 존재하는 리소스에 대해 단일화된 접근 인터페이스를 제공해주는 클래스가 없다.

이를 서비스 추상화를 이용해 만들어 보면 어떨까?

* **리소스**
  * 스프링은 자바의 일관성 없는 리소스 접근 API를 추상화해서 Resource라는 추상화 인터페이스를 정의
  * 리소스는 스프링에서 빈이 아닌 값으로 취급됨
  * 서비스를 제공해주는 것이 아니라 단순히 정보를 가진 값으로 지정
  * 추상화를 적용하는 방법에 문제가 있음
    * 빈으로 지정 불가
    * 외부에서 지정해도 property의 value 애트리뷰트를 넣는 방법 뿐 --> 문자열 only
* **리소스 로더**
  * 접두어를 이용해 Resource 오브젝트를 선언하는 방법 존재
    * 문자열 안에 리소스의 종류와 리소스의 위치를 함께 표현하게 해주는 것
  * 문자열로 정의된 리소스를 실제 Resource 타입 오브젝트로 변환해주는 ResourceLoader 제공
    * ResourceLoader도 인터페이스
  * 접두어의 예
    * file:
    * classpath:
    * none
    * http:
  * 대표적인 예
    * 스프링의 애플리케이션 컨텍스트
      * 스프링 설정정보가 담긴 xml 도 리소스 로더를 이용해 Resource로 읽어옴
    * 빈의 프로퍼티 값을 변환할 때
    * 스프링이 제공하는 빈으로 등록 가능한 클래스에 파일을 지정해주는 프로퍼티는 거의 모두 리소스 타입



## 7.4 인터페이스 상속을 통한 안전한 기능확장

서버가 운영 중인 상태에서 서버를 재시작하지 않고 긴급하게 애플리케이션이 사용 중인 SQL을 변경해야 하는 경우 어떻게 해야 할까?

### DI와 기능의 확장

* **DI를 의식히는 설계**
  * DI를 적용하려면 커다란 오브젝트 하나만 존재해서는 안됨
  * 최소한 두 개 이상의, 의존관계를 가지고 서로 협력해서 일하는 오브젝트가 필요
  * 그래서 적절한 책임에 따라 오브젝트 분리가 필요함
  * 항상 의존 오브젝트는 자유롭게 확장될 수 있다는 점을 염두에 둬야함
  * DI란 미래를 프로그래밍 하는 것
* **DI와 인터페이스 프로그래밍**
  * DI 다운 DI란 두 개의 오브젝트가 인터페이스를 통해 느슨하게 연결되는 것
  * 인터페이스를 사용하는 이유
    1. 다형성을 얻기 위해서
    2. 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확히 해줄 수 있으므로
       * **인터페이스 분리 원칙** : 오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클리이언트기 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요가 있음

### 인터페이스 상속

* 인터페이스를 여러개 만드는 대신 기존 인터페이스를 상속을 통해 확장하는 방법도 있다



## 7.5 DI를 이용해 다양한 구현 방법 적용하기

실제 구현을 해볼 차례이다.
운영중인 시스템에서 사용하는 정보를 실시간으로 변경하는 작업을 만들 때 고려해야 할 사항은 동시성 문제이다.
읽기 전용에서는 상관 없으나 수정은 다르다.

### ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리

* ConcurrentHashMap은 동기화된 해시 데이타 조작에 최적화 되어있다.
  * ConcurrentHashMap은 데이터 조작 시 전체 데이터에 대해 락을 걸지 않고 조회는 아예 사용하지 않음
  * 어느정도 안전하면서 성능이 보장되는 동기화된 HashMap으로 이용하기 적당
* **수정 가능 SQL 레지스트리 테스트 작성**
  * 수정 가능 SQL 레지스트리 구현

### 내장형 데이터베이스를 이용한 SQL 레지스트리 만들기

저장되는 데이터의 양이 많아지거 잦은 조회와 변경이 일어나는 환경이라면 내징형 DB를 이용하여 SQL을 저장하고 수장하는 것을 추천한다.
내장형 DB는 애플리케이션에 내장되어 애플리케이션과 함께 시작되고 종료되는 DB를 말한다.
데이터는 메모리에 저장되기 때문에 IO로 인해 발생하는 부하가 적어서 성능이 뛰어나다.
안정적인 방법으로 등록, 수정, 검색이 가능하고 최적화된 락킹, 격리수준, 트랜잭션을 적용할 수 있다.

* **스프링의 내징향 DB 지원 기능**

  * 자바에서 지원하는 내장형 DB
    * Derby
    * HSQL
    * H2
  * 위 모두 JDBC 드라이버를 제공하고 표준 DB와 호환되는 기능을 제공
  * 하지만 기존의 Datasource와 DAO를 사용하던 모델 그대로 사용하는 건 좋은 방법이 아니다.
    * 외부 DB 생성과 다른 초기화 작업이 별도로 필요하기 때문
  * 스프링은 내장형 DB를 초기화하는 작업을 지원하는 편리한 내장형 DB 빌더 제공

* **내장형 DB 빌더 학습 테스트**

  * 내장형 DB는 애플리케이션을 통해 DB가 시작될 때마다 매번 테이블을 새롭게 생성한다;

    * 따라서 지속적으로 사용 가능한 테이블 생성 SQL 스크립트를 준비해둰야 함
    * 초기 데이터도 미리 준비해뒀다가 DB가 시작될 때 실행되게 해야 함

  * 스프링이 제공하는 내장형 DB 빌더는 EmbeddedDatabaseBuilder이다.

    ```java
    new EmbeddedDatabaseBuilder()
      	.setType(내장형 DB 종류)
        .addScript(초기화에 사용할 DB 스크립트의 리소스)
        ...
        .build();
    ```

  * EmbeddedDatabaseBuilder 빌더가 최종적으로 만들어주는 오브젝트는 DataSource를 상속한 EmbeddedDatabase 타입이다.

* **내장형 DB를 이용한 SqlRegistry 만들기**
  * UpdatableSqlRegistry 테스트 코드의 재사용



### 트랜잭션 적용

EmbeddedSqlRegistry에 사용된 SimpleJdbcTemplate는 트랜잭션이 적용되어 있지 않다.
그렇다면 Map을 통해 여러 개의 데이터를 업데이트 하는 도중 에러가 발생한다면 롤백이 되지 않고 그냥 작업이 중단될 것이다.
내장형 DB는 트렌젝션 적용이 쉽다.

* **다중 SQL 수정에 대한 트랜잭션 테스트**
  * 코드를 이용한 트랜잭션 적용







