# 1장 오브젝트와 의존관계

> 오브젝트 설계와 구현, 동작 원리에 집중하자
> 
> 
> 객체지향 설계의 기초와 원칙, 디자인 패턴, 리팩토링, 단위테스트 등
> 

## **1.1 초난감 DAO**

### **코드 리팩토링**

### **1. User 클래스 생성, UserDAO 클래스 생성**

- 문제가 매우 많은 상태

## **개념 공부**

> DAO (Data Access Object)
> 
> 
> DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하는 오브젝트
> 

> 자바빈
> 
> 
> JSP에서 객체를 가져오기 위한 기법
> 자바로 작성된 컴포넌트들 즉, 클래스를 일반적으로 말함
> 설계규약을 따라야 함
> 
> - 생성자는 매개변수가 존재하지 않아야 함
> - get, set 메소드가 존재해야 함
> - 멤버변수의 접근제어자는 private, 각 getter setter 메서드와 클래스의 접근제어자는 public 으로 정의

---

## **1.2 DAO의 분리**

### **코드 리팩토링**

1. User 클래스 생성, UserDAO 클래스 생성

### **2. 메소드 추출 - getConnection()**

### **3. 상속을 통한 확장**

- 상속은 한번만 가능
- 슈퍼클래스와 서브클래스의 관계가 밀접하다

**개발자가 고려해야 하는 사항 - 분리와 확장**

사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전함을 기억하자
그러므로 미래의 변화를 어떻게 대비할 지를 생각하면서 개발해야 한다

변화의 영향을 최소화 하는 법은 **분리와 확장을 고려하여 설계**하는 것이다

변화는 한가지 관심에 집중돼서 발생한다
그러므로 한가지 관심을 한 곳에 집중 되도록 하자 
관심이 같은 것끼리 모으고 다른 것을 따로 떨어져 있도록 => 관심사의 분리

상속을 통한 확장

### **개념 공부**

> 리팩토링
> 
> 
> 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
> 장점 : 생상성 향상, 코드의 품질 향상, 유지보수 용이
> 

> 디자인 패턴
> 
> 
> 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션 의미
> 패턴의 설계 구조는 보면 대부분 비슷한데, 문제 해결을 위해 적용 가능한 방법이 두가지 구조로 정리되기 때문이다
> 
> - 클래스 상속과 오브젝트 합성

> 템플릿 메소드 패턴
> 
> 
> 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
> 변하지 않는 기능은 슈퍼클래스에 만들어 두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다
> 추상메소드 혹은 오버라이드 가능한 메소드 정의 (훅 메소드)
> 서브클래스는 추상메소드 혹은 훅 메소드를 오버라이드 하는 방법을 이용해 기능의 일부를 확장한다
> 

> 팩토리 메소드 패턴
> 
> 
> 상속을 통해 기능을 확장하게 하는 패턴
> 기존의 코드의 변경 없이 확장하기 위한  디자인 패턴
> 객체를 생성할 때 어떤 클래스의 인스턴스를 만들 지 서브클래스에서 결정하도록 함
> 

---

## **1.3 DAO의 확장**

### **코드 리팩토링**

1. User 클래스 생성, UserDAO 클래스 생성
2. 메소드 추출 - getConnection()
3. 상속을 통한 확장

### **4. 클래스 분리 - SimpleConnectionMaker**

- 클래스의 종속 때문에 UserDAO 코드의 수정이 불가피하다

### **5. 인터페이스를 통한 추상화 작업 - ConnectionMaker**

- 클래스의 구체적인 정보는 모두 제거가 가능
- 하지만 초기 어떤 클래스의 오브젝트를 사용할지 결정하는 생성자 코드가 제거되지 않음

### **6. 클라이언트에 관심 떠넘기기 - UserDaoTest**

- UserDAO의 클라이언트를 통해 오브젝트 전달 받음
- 생성자 파라미터 이용
- 테스트를 위한 클래스가 다른 책임을 떠맡고 있음
    - UserDao, ConnectionMaker 구현 클래스와 오브젝트를 만드는 것
    - 두 개의 오브젝트가 연결되도록 관계를 맺어주는 것

**클래스 사이의 관계**

한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 것
클래스 안에 클래스가 직접적으로 들어가 있는 경우
코드에 다른 클래스 이름이 나타나기 때문에 만들어 짐

**오브젝트 사이의 관계**

런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식
코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용 가능
오브젝트 사이에 런타임 사용관계 또는 링크 또는 의존 관계라고 불리는 관계를 맺어주면 됨

### **개념 공부**

> 개방 폐쇄 원칙 (OCP)
> 
> 
> 클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀 있어야 한다
> 기능 확장은 얼마든지 가능하고 핵심기능은 변화에 영향을 받지 않고 유지되는 상태
> 

> 객체지향 설계 원칙 (SOLID)
> 
> 
> 객체지향의 특징을 잘 살릴 수 있는 설계의 특징으로 절대적인 기준이 아닌 가이드라인 
> 디자인 패턴은 구체적인 솔루이고, 객체지향 설계 원칙은  일반적인 상황에서 적용 가능한 기준
> 
> - SRP 단일 책임 원칙
> - OCP 개방 폐쇄 원칙
> - LSP 리스코프 치환 원칙
> - ISP 인터페이스 분리 원칙
> - DIP 의존관계 역전 원칙

> 높은 응집도 낮은 결합도
> 
> 
> > 높은 응집도
> > 
> > 
> > 변화가 일어날 때, 해당 모듈에서 변하는 부분이 크다는 것을 의미
> > 모듈의 일부분만 변화 한다면 이는 바뀌지 않은 부분에 대해 신경을 써야 한다는 부담이 생김
> > 
> > **낮은 결합도**
> > 
> > 하나의 변경이 발생할 때, 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 의미
> > 

> 전략패턴
> 
> 
> 현재 6번까지 진행된 상태의 구조 (UserDaoTest - UserDao - ConnectionMaker)
> 자신의 기능 컨텍스트(UserDao)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스(ConnectionMaker)로 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스(NConnectionMaker)를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴
> 

---

## **1.4 제어의 역전 (IoC)**

### **코드 리팩토링**

1. User 클래스 생성, UserDAO 클래스 생성
2. 메소드 추출 - getConnection()
3. 상속을 통한 확장
4. 클래스 분리 - SimpleConnectionMaker
5. 인터페이스를 통한 추상화 작업 - ConnectionMaker
6. 클라이언트에 관심 떠넘기기 - UserDaoTest

### **7. 팩토리에서 UserDao와 ConnectionMaker 생성 - DaoFactory**

### **8. 여러개의 Dao 메소드가 생긴다면 메소드 추출!**

### **제어의 역전**

제어의 역전

- 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음
- 모든 제어 권한을 다른 상대에 위임
- 프레임워크 : 내가 가져다 사용됨 (수동)
    - 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명 주기 관리 등을 관장

일반적인 프로그램의 흐름

- 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정
- 언제 어떻게 그 오브젝트를 만들지 스스로 관장
- 사용하는 쪽에서 모든 작업을 제어
- 라이브러리 : 내가 가져다가 사용 (능동)

---

## 1.5 스프링의 IoC

### 빈

- 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
- 스프링 컨테이너가 생성과 관계설정, 사용등을 제어해주는 제어의 역전이 적용된 오브젝트
- **애플리케이션의 모든 오브젝트가 빈은 아니다**

### 빈 팩토리

- 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트

### 애플리케이션 컨텍스트

- 빈 팩토리의 확장판 ( 빈 팩토리 상속 )
- 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진
- 동작방식
    - 설정정보에서 @Bean이 붙은 메소드의 이름을 가져와 빈 목록 생성
    - 클라이언트가 getBean을 호출하면, 자신의 빈 목록에서 요청한 이름이 있는지 검색
    - 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성 ( DaoFactory에서 진행 )
    - 클라이언트에 리턴
- 장점
    - 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다
        - 추가될 다양한 팩토리 클래스를 알 필요 없고, 일관된 방식으로 원하는 오브젝트를 가져올 수 있음
    - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다
        - 오브젝트가 만들어지는 방식, 시점과 전략을 다르게, 자동생성, 후처리, 정보의 조합, 인터셉팅 등의 다양한 기능 제공
        - 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공
    - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다

```java
ApplicationContext context = 
                            new AnnotationConfigApplicationContext(DaoFactory.class);
UserDao dao = context.getBean("userDao", UserDao.class);
                                            // getBean(빈의이름, 리턴타입)
```

## 설정정보

```java
@Configuration
public class DaoFactory {
    @Bean
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }
    
    @Bean
    public ConnectionMaker() {
        return new DConnectionMaker();
    }
}
```

### 컨테이너 , IoC 컨테이너

- IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너라고 지칭
- 컨테이너 자체가 IoC의 개념을 담고 있다

---

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

> 동일성 : 완전히 같은 하나의 오브젝트만 존재하는 것
> 

> 동등성 : 동일한 정보를 담고 있는 오브젝트들
> 

### 애플리케이션 컨텍스트 ⇒ 싱글톤 레지스트리

- 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다
- 싱글톤을 생성하고, 관리하고, 공급한다.
- 장점
    - 평번한 자바 클래스를 싱글톤으로 활용하게 해줌
    - public 생성자를 가질 수 있음
    - 테스트 환경에서 자유롭게 오브젝트 생성이 가능, 목 오브젝트 대체도 간단
    - 기존의 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계방식과 원칙 디자인 패턴등을 적용하는데 제약이 없음
- 주의해야 할 점
    - 무상태 방식으로 만들어져야 한다
        - 데이터를 클라이언트에서 다 넘겨주는 방식?
    - 인스턴스 변수 수정은 매우 위험하다
    - 파라미터와 로컬변수, 리턴값을 이용하자
    - `static final`, `final` 키워드 이용

### 왜 싱글톤 빈인가?

- 서버 환경이기 때문이다
- 멀티스레드 환경에서 하나의 오브젝트를 공유해 동시에 사용한다

### 싱글톤 패턴의 한계

- 상속이 불가능하다
- 테스트하기 힘들다
- 서버환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다
- 전역상태를 만들 수 있으므로 바람직 하지 못하다

### 스프링 빈의 스코프

- 싱글톤
    - 기본 스코프
    - 컨테이너 내 한 개의 오브젝트만 만들어서 컨테이너가 존재하는 동안 유지
- 프로토타입
    - 컨테이너에 빈을 요청할 때마다 새로운 오브젝트 생성
- request
    - http 요청이 들어올 때마다 새롭게 생성
- session

---

## 1.7 의존관계 주입 (DI)

### 의존관계

- A가 B에 의존하고 있을 때, B가 변하면 A에 영향을 미친다는 것
- 의존관계에는 방향성이 존재한다
- UserDao는 ConnectionMaker에 의존하고 있음
    - 인터페이스 의존관계는 인터페이스 구현 클래스와의 관계는 느슨해진다

### 의존관계 주입

- 스프링 IoC 기능의 대표적인 동작원리
- 오브젝트 레퍼런스를 외부로부터 주입받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심
- 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점
- DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다
- 조건
    - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다
    - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다
    - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다
- 장점
    - 런타임 클래스에 대한 의존관계가 나타나지 않음
    - 인터페이스를 통해 결합도가 낮은 코드 생성
    - 다른 책임을 가진 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않음
    - 변경을 통한 다양한 확장방법에 자유로움
    - **부가기능 추가**

### 의존관계 검색

- 자신이 필요한 오브젝트를 능동적으로 찾음
- 런타임시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 맡기지만, 이를 가져올 떄는 메소드나 생성자를 통한 주입 대신 **스스로 컨테이너에게 요청하는 방법** 사용
- 애플리케이션 컨텍스트의 `getBean`이 그 예시
- 의존관계 검색 방식에서는 검색하는 오브젝트는 **자신이 스프링 빈일 필요가 없다**

### 메소드를 이용한 의존관계 주입

- 수정자 메소드를 이용한 주입
    - set 메소드
    - 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장
- 일반 메소드를 이용한 주입
    - 여러개의 파라매터를 가질 수 있다

---

## 1.8 XML을 이용한 설정

### XML 설정

|  | 자바 코드 설정정보 | XML 설정정보 |
| --- | --- | --- |
| 빈 설정파일 | @Configuration | <beans> |
| 빈의 이름 | @Bean methodName() | <bean id=”methodName” |
| 빈의 클래스 |  return new BeanClass(); | class=”spring.boot.~.BeanClass” /> |
| 빈의 의존 오브젝트 | userDao.setConnectionMaker(connectionMaker()); | <property name=”connectionMaker” ref=”connectionMaker” /> |

### XML을 이용하는 애플리케이션 컨택스트

```java
ApplicationContext context = 
                        new GenericXmlApplicationContext("applicationContext.xml");
```

### DataSource 인터페이스로 변환

### 프로퍼티 값의 주입

- 빈이 아닌 값을 주입 할 때
    - ref 대신 value 사용

```xml
<property name="driverClass" value="com.mysql.jdbc.Driver" />
<property name="uesrname" value="spring" />
```

---

## 1.9 정리

> 스프링이란 ‘어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크’
>
