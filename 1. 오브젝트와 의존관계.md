# 1장 오브젝트와 의존관계

   

> **오브젝트 설계와 구현, 동작 원리에 집중하자**
>
> 객체지향 설계의 기초와 원칙, 디자인 패턴, 리팩토링, 단위테스트 등

   

## 1.1 초난감 DAO

   

### 코드 리팩토링

#### 1. User 클래스 생성, UserDAO 클래스 생성

* 문제가 매우 많은 상태

​      

​      

## 개념 공부

> **DAO (Data Access Object)**
>
> DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하는 오브젝트

> **자바빈**
>
> JSP에서 객체를 가져오기 위한 기법
> 자바로 작성된 컴포넌트들 즉, 클래스를 일반적으로 말함
> 설계규약을 따라야 함
>
> * 생성자는 매개변수가 존재하지 않아야 함
> * get, set 메소드가 존재해야 함
> * 멤버변수의 접근제어자는 private, 각 getter setter 메서드와 클래스의 접근제어자는 public 으로 정의

   

   

---

## 1.2 DAO의 분리

   

###코드 리팩토링

1. User 클래스 생성, UserDAO 클래스 생성

####  2. 메소드 추출 - getConnection()

####  3. 상속을 통한 확장

* 상속은 한번만 가능
* 슈퍼클래스와 서브클래스의 관계가 밀접하다



**개발자가 고려해야 하는 사항 - 분리와 확장**

사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전함을 기억하자
그러므로 미래의 변화를 어떻게 대비할 지를 생각하면서 개발해야 한다

변화의 영향을 최소화 하는 법은 **분리와 확장을 고려하여 설계**하는 것이다

​	변화는 한가지 관심에 집중돼서 발생한다
​	그러므로 한가지 관심을 한 곳에 집중 되도록 하자 
​	관심이 같은 것끼리 모으고 다른 것을 따로 떨어져 있도록 => 관심사의 분리 

​	상속을 통한 확장



### 개념 공부

> ####리팩토링
>
> 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
> 장점 : 생상성 향상, 코드의 품질 향상, 유지보수 용이 

> ####디자인 패턴
>
> 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션 의미
> 패턴의 설계 구조는 보면 대부분 비슷한데, 문제 해결을 위해 적용 가능한 방법이 두가지 구조로 정리되기 때문이다
>
> - 클래스 상속과 오브젝트 합성

> ####템플릿 메소드 패턴
>
> 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법
> 변하지 않는 기능은 슈퍼클래스에 만들어 두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다
> 추상메소드 혹은 오버라이드 가능한 메소드 정의 (훅 메소드)
> 서브클래스는 추상메소드 혹은 훅 메소드를 오버라이드 하는 방법을 이용해 기능의 일부를 확장한다

> ####팩토리 메소드 패턴
>
> 상속을 통해 기능을 확장하게 하는 패턴
> 기존의 코드의 변경 없이 확장하기 위한  디자인 패턴
> 객체를 생성할 때 어떤 클래스의 인스턴스를 만들 지 서브클래스에서 결정하도록 함

​    

   

---

## 1.3 DAO의 확장

   

###코드 리팩토링

1. User 클래스 생성, UserDAO 클래스 생성
2. 메소드 추출 - getConnection()
3. 상속을 통한 확장

####  4. 클래스 분리 - SimpleConnectionMaker

* 클래스의 종속 때문에 UserDAO 코드의 수정이 불가피하다

 ####  5. 인터페이스를 통한 추상화 작업 - ConnectionMaker

* 클래스의 구체적인 정보는 모두 제거가 가능
* 하지만 초기 어떤 클래스의 오브젝트를 사용할지 결정하는 생성자 코드가 제거되지 않음

 ####  6. 클라이언트에 관심 떠넘기기 - UserDaoTest

* UserDAO의 클라이언트를 통해 오브젝트 전달 받음 
* 생성자 파라미터 이용
* 테스트를 위한 클래스가 다른 책임을 떠맡고 있음 
  * UserDao, ConnectionMaker 구현 클래스와 오브젝트를 만드는 것
  * 두 개의 오브젝트가 연결되도록 관계를 맺어주는 것

 

**클래스 사이의 관계**

한 클래스가 인터페이스 없이 다른 클래스를 직접 사용한다는 것
클래스 안에 클래스가 직접적으로 들어가 있는 경우
코드에 다른 클래스 이름이 나타나기 때문에 만들어 짐

**오브젝트 사이의 관계**

런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식
코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용 가능
오브젝트 사이에 런타임 사용관계 또는 링크 또는 의존 관계라고 불리는 관계를 맺어주면 됨

   

### 개념 공부

> ####개방 폐쇄 원칙 (OCP)
>
> 클래스나 모듈은 확장에는 열려있어야 하고 변경에는 닫혀 있어야 한다
> 기능 확장은 얼마든지 가능하고 핵심기능은 변화에 영향을 받지 않고 유지되는 상태

> #####객체지향 설계 원칙 (SOLID)
>
> 객체지향의 특징을 잘 살릴 수 있는 설계의 특징으로 절대적인 기준이 아닌 가이드라인 
> 디자인 패턴은 구체적인 솔루이고, 객체지향 설계 원칙은  일반적인 상황에서 적용 가능한 기준
>
> * SRP 단일 책임 원칙
> * OCP 개방 폐쇄 원칙
> * LSP 리스코프 치환 원칙
> * ISP 인터페이스 분리 원칙
> * DIP 의존관계 역전 원칙

> ####높은 응집도 낮은 결합도
>
> > **높은 응집도**
> >
> > 변화가 일어날 때, 해당 모듈에서 변하는 부분이 크다는 것을 의미
> > 모듈의 일부분만 변화 한다면 이는 바뀌지 않은 부분에 대해 신경을 써야 한다는 부담이 생김
> >
> > **낮은 결합도**
> >
> > 하나의 변경이 발생할 때, 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 의미

> #### 전략패턴
>
> 현재 6번까지 진행된 상태의 구조 (UserDaoTest - UserDao - ConnectionMaker)
> 자신의 기능 컨텍스트(UserDao)에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스(ConnectionMaker)로 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스(NConnectionMaker)를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴

​      

​      

---

##1.4 제어의 역전 (IoC)

   

### 코드 리팩토링

1. User 클래스 생성, UserDAO 클래스 생성
2. 메소드 추출 - getConnection()
3. 상속을 통한 확장
4. 클래스 분리 - SimpleConnectionMaker
5. 인터페이스를 통한 추상화 작업 - ConnectionMaker
6. 클라이언트에 관심 떠넘기기 - UserDaoTest

####  7. 팩토리에서 UserDao와 ConnectionMaker 생성 - DaoFactory

####  8. 여러개의 Dao 메소드가 생긴다면 메소드 추출!

   

####제어의 역전

제어의 역전

* 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음
* 모든 제어 권한을 다른 상대에 위임
* 프레임워크 : 내가 가져다 사용됨 (수동)
  * 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명 주기 관리 등을 관장

일반적인 프로그램의 흐름

* 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정
* 언제 어떻게 그 오브젝트를 만들지 스스로 관장
* 사용하는 쪽에서 모든 작업을 제어
* 라이브러리 : 내가 가져다가 사용 (능동)





