# 2장 테스트

<br/>
**스프링이 개발자에게 제공하는 가장 중요한 가치** ⇒ 객체지향과 테스트
**복잡한 애플리케이션 개발에 필요한 도구** ⇒ 객체지행 기술과 테스트

<br/>                
### 복잡하고 발전하는 애플리케이션에 대응하는 전략

1. 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI와 같은 기술
2. 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술

                
<br/>
## 2.1 UserDaoTest 다시보기
<br/>
### 웹을 통한 DAO 테스트 방법의 문제점

- 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다
- 테스트 중 에러가 발생하면 어디에서 문제가 발생했는지를 찾아내야하는 수고가 필요
    - 에러의 정확한 원인 파악이 힘듬
    - 너무나도  다양한 이유로 에러가 발생할 수 있음
    - 테스트하고자 한 파트가 아닌 다른 곳에서 에러가 발생

                
<br/>
### 작은 단위의 테스트

- 가능하면 작은 단위로 쪼개서 테스트 진행
- ‘관심사의 분리’ 원리 적용
- 단위 테스트
    - 크기와 범위가 정해지지 않음
    - 하나의 관심에 집중해서 효율적으로 테스트 할만한 범위의 단위
    - but, 단위는 작을수록 좋다!
    - 개발자 테스트 or 프로그래머 테스트
- 각 단위별로 테스트를 진행하고 전체 테스트를 진행하면 오류를 줄일 수 있다

               

### 자동수행 테스트 코드

- 메소드 실행으로 테스트 전 과정이 자동으로 실행
    - 테스트가 자동으로 수행된다는 점은 개발자의 부담을 줄여준다는 점에서 매우 중요하다
- 별도의 테스트용 클래스를 만드는 편이 좋다
- 자주 테스트가 가능
- 수정 후 빠르게 전체 테스트를 수행하여 수정 때문에 다른 기능애 문재가 발생하지 않는지 확인 가능

               

### 지속적인 개선과 점진적인 개발을 위한 테스트

- 매우 작은 단계를 거쳐가면서 계속 코드를 개선해 나갈 수 있다
- 기능을 추가해 가면서 테스트도 추가하면서 점진적인 개발이 가능하다
    - 새로운 기능 추가가 기존의 코드에 영향을 미치지 않는지 확인 가능
    
                
    

### UserDaoTest의 문제점

- 수동 확인 작업의 번거로움
    - 입력 값과 가져온 값이 일치하는지는 알 수 없다는 점
    - 테스트의 결과를 확인하는 작업이 수동이라는 점
- 실행작업의 번거로움
    - main 메소드를 하나하나 실행시켜야 한다는 점
    - 종합해서 전체 테스트를 하기 힘들다는 점

           

## 2.2 UserDaoTest 개선

**테스트 에러**: 테스트가 진행되는 동안에 `에러가 발생`해서 실패하는 경우

**테스트 실패**: 테트 작업 중 에러는 발생하지 않았으나 그 `결과`가 기대한 것과 다르게 나오는 경우

        

### **JUnit: 자바 테스팅 프레임워크**

- 일정한 패턴을 가진 테스트를 만들 수 있음
- 많은 테스트를 간단히 실행시킬 수 있음
- 테스트 결과를 종합해서 볼 수 있음
- 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춤
- **프레임워크: 기본 동작 원리 ⇒ IoC**
    - 프레임워크는 개발자가 만든 클래스의 권한을 넘겨받아 주도적으로 애플리케이션의 흐름 제어

              

### JUnit 프레임워크 조건

1. public 메소드
2. @Test 애노테이션

```java
@Test
public void addAndGet() throws SQLException {
	ApplicationContext Context = 
					new ClassPathXmlApplicationContext("applicationContext.xml");
	...
}
```

              

### JUnit 검증코드

```java
assertThat("actual", is("expected")) == assertEquals("expected", "actual") 
	// 객체 actual과 expected가 같은 값을 가지는지 확인한다
assertThat(new int[] a, is(new int[] b)) == assertArrayEquals(a, b) 
	// 배열 a와 b가 일치함을 확인한다
assertThat(actual, sameInstance(expected)) == assertSame(expected, actual) 
	// 객체 actual와 expected가 같은 객체임을 확인한다
assertThat(actual, is(true)) == assertTrue(actual) 
	// 조건 actual가 참인지 확인한다
assertThat(actual, notNullValue) == assertNotNull(actual) 
	// 객채 actaul가 null이 아님을 확인한다
```

            

### 테스트 코드 작성 공통 규칙

```java
@DisplayName("테스트 코드 작성 공통 규칙") // 안 붙이면 default로 생성
@Test
public void addAndGet() {
	// given: 변수, 입력 값, 객체 정의
	ApplicationContext context = 
							new GenericXmlApplicationContext("applicationContext.xml");
	
	UserDao dao = context.getBean("userDao", UserDao.Class);
	User user = new User();
	user.setId("gyume");
	...

	// when: 액션하는 테스트 실행하는 과정
	dao.add(user);
	
	User user2 = dao.get(user.getId());

	// then: 테스트 검증
	assertThat(user2.getName(), is(user.getName());
}
```

            

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

### 테스트 결과의 일관성

반복적으로 테스트를 했을 때 테스트가 실패와 성공을 반복 한다면 이는 좋은 테스트라고 할 수 없다.

- **코드에 변경사항이 없다면 단위 테스트는 항상 일관성 있는 결과가 보장 되어야 한다**
- 외부 환경에 영향을 받아서는 안된다 (DB의 남은 데이터와 같이)
- 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되어야 한다
    - 테스트는 어떤 순서로 진행될지 알 수 없다 - 순서 보장 안됨!

         

### 예외상황 발생시 성공하는 테스트

```java
@Test(expected=EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLExceptions {
	...
	dao.get("unknown_id");
}
```

      

### 포괄적인 테스트

- 개발자는 성공하는 테스트만 골라서 만드는 실수를 한다
- 부정적인 케이스를 먼저 만드는 습관을 들여야 한다
- 그래야 포괄적인 테스트를 만들 수 있다

       

**테스트 코드: 잘 작성된 하나의 기능 정의서, 코드로 된 설계문서**

### 테스트 주도 개발 (TDD, TFD)

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 **테스트 코드를 먼저 만들고,** 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법

> **실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다** - TDD 기본 원칙
> 

      

**특징**

- 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만든다
- 테스트를 빼먹지 않고 꼼꼼히 작성한다
- 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다
- 코드를 만들고 **테스트를 수행할 때까지 걸리는 시간이 0에 가깝다**
- 코드에 대한 **피드백을 매우 빠르게** 받을 수 있게 된다
- 개발자들은 **이미 머릿속에서 테스트**를 돌리면서 개발을 하고 있다
    - 제약이 심하고, 오류가 많고, 다시 반복이 어려울 뿐!
    - 실제 코드로 끄집어 내면 TDD가 된다
- **오류를 빨리 발견이 가능하다 ⇒ 빠른 수정이 가능하다**
- 이전 엔터프라이즈 애플리케이션의 테스트는 매우 어려웠으나 스프링의 등장 이후로 쉬운 일이 되었다
    
       
    

### JUnit의 테스트 수행 방식

> JUnit5 부터 
**@Before —> @BeforeEach, @After —> @AfterEach** 로 전환됨
> 
1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다
2. 테스트 클래스의 오브젝트를 하나 만든다
3. ~~@Before~~가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다
5. ~~@After~~가 붙은 메소드가 있으면 실행한다
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다
7. 모든 테스트의 결과를 종합해서 돌려준다

**** 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다**

- 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해서

    

픽스쳐: 테스트를 수행하는데 필요한 정보나 오브젝트로 일반적으로 여러 테스트에서 반복적으로 사용된다.

    

## 2.4 스프링 테스트 적용

         

스프링 빈을 생성하는 애플리테이션 컨텍스트의 생성 방식이 문제 - 빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 시간이 많이 든다.

### 스프링 테스트 컨텍스트 프레임워크 적용

> JUnit5 부터 
@RunWith —> **@ExtendWith** 전환됨
> 

```java
~~@RunWith(SpringWithJUnit4ClassRunner.class)~~
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
	@Autowired
	private ApplicationContext context;
	
	...
}
```

- **@ExtendWith(SpringExtension.class)**
    - JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고
    관리하는 작업을 진행해 준다
    - 이 확장기능은 테스트가 실행되기 전에 딱 한번만 애플리케이션 컨텍스트를 생성하고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트를 자신의 테스트 오브젝트의 특정 필드에 주입해 주는 것이다
    - 여러개의 메소드가 하나의 애플리케이션 컨텍스트를 공유할 수 있도록 한다
- **@ContextConfiguration(locations="/applicationContext.xml")**
    - 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것
- **@Autowired**
    - 인스턴스 변수에 이 애노테이션이 붙어있으면 테스트 컨텍스트 프레임워크는 `변수 타입`과 일치하는 
    `컨텍스트 내의 빈`을 찾는다
    - 타입이 일치하는 빈이 있으면 이를 인스턴스 변수에 주입해 준다
    - 타입 정보를 통한 **자동 와이어링**
    - 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다 (인터페이스도 가능)
    - 같은 타입의 빈이 두개 이상 있는 경우 변수와 **이름이 같은 빈**을 가져온다
- 스프링 애플리케이션 컨텍스트는 초기화 할 때 자기 자신도 빈으로 등록한다

### 테스트 코드에 의한 DI

- 테스트 중에 DAO가 사용할 DataSource 오브젝트를 바꿔주는 방법을 사용한다
    
    ```java
    DataSource dataSource = new SingleConnectionDataSource(
    			"jdbc:mysql://localhost/testdb", "spring", "book", true);
    dao.setDataSource(dataSource);
    ```
    
- 이 방법의 장점은 XML 설정 파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다는 점이다
    - but, 설정정보를 따라 구성한 오브젝트를 가져와 의존관계를 강제로 변경했기 떄문에 주의해서 사용
- 한번 변경된 컨텍스트는 전체 테스트 내내 변경된 상태가 유지된다
    - 이는 바람직 하지 않음
    - **@DirtiesContext**
        - 이 애노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려줌
        - 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 콩유를 허용하지 않음
        - 테스트가 끝나면 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트에 제공
        - 메소드 레벨에서도 사용이 가능하다

           

### 테스트를 위한 별도의 DI 설정

- 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어 두는 방법을 이용
- test-applicationContext.xml 파일 생성
    
    ```java
    ~~@RunWith(SpringWithJUnit4ClassRunner.class)~~
    @ContextConfiguration(locations="/test-applicationContext.xml")
    public class UserDaoTest {...}
    ```
    

          

### 컨테이너 없는 DI 테스트

- 스프링 컨테이너를 사용하지 않고 테스트를 만드는 방법
    
    ```java
    public class UserDaoTest {
    	UserDao dao;
    	...
    	@Before
    	public void setUp() {
    		...
    		dao = new UserDao();
    		DataSource dataSource = new SingleConnectionDataSource(
    							"jdbc:mysql://localhost/testdb", "spring", "book", true);
    		dao.setDataSource(dataSource);
    	}
    }
    ```
    
- DataSource를 직접 만드는 번거로움은 있으나 애플리케이션 컨텍스트를 아예 사용하지 않으니 코드는 더 단순해지고 이해하기 편해짐
- 테스트 시간도 절약됨
- 하지만 매번 새로운 UserDao 오브젝트가 생성된다는 단점도 존재 - 하지만 가볍지!

> ***DI는 객체지향 프로그래밍 스타일이다
DI를 위해 컨테이너가 반드시 필요한 것은 아니다
DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐 
컨테이너가 DI를 가능하게 해주는 것은 아니다***
> 

        

침투적 기술: 특정 인터페이스나 클래스를 사용하도록 강제하는 기술, 코드가 해당 기술에 종속된다

비침투적 기술: 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능, 순수한 코드 유지 ⇒ **스프링**

### DI를 이용한 테스트 방법 선택

1. 스프링 컨테이너 없이 테스트 할 수 있는 방법
    - 속도가 가장 빠르고 테스트가 간결
    - 오브젝트 생성과 초기화가 단순한 경우
2. 스프링의 설정을 이용한 DI 방식 사용
    - 여러 오브젝트와 복잡한 의존관계를 갖고 있는 경우
    - 각각 다른 설정파일을 만들어 사용하자
3. 수동 DI

           

## 2.5 학습 테스트로 배우는 스프링

### 학습 테스트

자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리에 대해서 테스트를 작성하는 것

********목적********

- 사용 방법 익히기
- 테스트를 진행하려는 기술이나 기능에 대해 제대로 이해하고 있는지 검정
- 테스트 코드를 작성해보면서 빠르고 정확하게 사용법을 익히는 것

**장점**

- 다양한 조건에 따른 기능을 손쉽게 확인 가능하다
    - 자동화된 테스트의 모든 장점이 적용됨
- **학습 테스트 코드를 개발 중에 참고할 수 있다**
    - 샘플 코드로써 참고 가능
    - 초기화, 설정방법, API 호출 방법 등
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다
    - 학습 테스트를 통해 기존의 API의 변화나 버그등을 미리 발견할 수 있다
- 테스트 작성에 대한 좋은 훈련이 된다
- 새로운 기술을 공부하는 과정이 즐거워진다..? **YES!**

     

### 버그 테스트

코드에 오류가 있을 때 그 오류를 가장 잘 드러내 줄 수 있는 테스트

**장점**

- 테스트의 완성도를 높여준다
- 버그의 내용을 명확하게 분석하게 해준다
    - 문제를 명확히 알아야 테스트를 만들 수 있다
- 기술적인 문제를 해결하는 데 도움이 된다

동등분할: 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트 하는 방법

경계값 분석: 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법  ( 예시) 0, 최대, 최소 )
