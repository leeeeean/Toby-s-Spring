# 3장 템플릿

> 템플릿: 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법
> 

## 3.1 다시 보는 초난감 DAO

- JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 `try/catch/finally` 구문을 사용하도록 권장
- 커넥션 풀
    - 미리 정해진 풀안에 제한된 수의 리소스를 만들어두고 필요할 때 이를 할당하고 반환하면 다시 풀에 넣는 방식으로 운영
    - 매번 새로운 리소스를 생성하는 대신 풀에 미리 만들어둔 리소스를 돌려가며 사용하는 편이 훨씬 유리

## 3.2 변하는 것과 변하지 않는 것

### **try/catch/finally 코드의 문제점**

- 복잡한 코드의 중첩 및 반복
- 복사, 붙여넣기의 반복
    - 잘못 작성시 에러 발생 !
- 코드 수정시 잘못 삭제 할 수 있음
- 예외상황을 처리하는 테스트는 어렵고 번거로움

### 핵심

변하지 않는, 그러나 많은 곳에서 **중복되는 코드**와 로직에 따라 **자꾸 확장되고 자주 변하는 코드**를 잘 분리해내는 작업

### 다양한 디자인 패턴 적용

- **메소드 추출**
    - 분리시키고 남은 메소드가 재사용이 필요한 부분
    - 뷴랃한 메소드는 확장이 필요
    - 잘못됨
- **템플릿 메소드 패턴**
    - 변하지 않는 부분은 슈퍼클래스에 변하는 부분은 추상메소드로
    - DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다
        - 메소드가 4개일 경우, 클래스 4개 생성
    - 확장구조가 고정됨
        - 관계의 유연성이 떨어짐
- **전략 패턴**
    - 개방폐쇄원칙을 잘 지키는 구조
    - 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어남
    - 오브젝트를 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만듬
    - **but! 컨텍스트 안에서 이미 구체적인 전략 클래스를 사용하도록 고정되어있는 것은 이상하다**
- **DI 적용을 위한 클라이언트 / 컨텍스트 분리**
    - 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달 ⇒ DI 구조
    - 관심사의 분리

## 3.3 JDBC 전략패턴의 최적화

### **개선할 부분**

- DAO 메소드마다 새로운 구현클래스를 만들어야 한다는 점
- 전달해야하는 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점

### 해결 방법

- **로컬 클래스**
    - UserDao 클래스 안에 내부 클래스로 정의하는 방법
    - 클래스 파일을 줄일 수 있음
    - 내부 클래스 특징을 이용해 로컬 변수를 바로 가져다 사용 가능
- **익명 내부 클래스**
    - 위의 장점에 더해서 이름을 없앨 수 있다
    - 변수에 담아둘 필요가 없음

**중첩 클래스의 종류**

- 다른 클래스 내부에 정의되는 클래스를 중첩 클래스라고 한다
- static class : 독립적인 오브젝트로 만들어질 수 있음
- inner class(내부 클래스) : 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있음
    - 내부 멤버 클래스 : 멤버 필드처럼 오브젝트 레벨에 정의
    - 로컬 클래스 : 메소드 레벨에 정의
    - 익명 내부 클래스 : 이름을 갖지 않음, 선언된 위치에 따라 범위가 달라짐
        - 클래스 선언과 오브젝트 생성이 결합된 형태
        - 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우 유용
        - `new interfaceName() { ... };`

## 3.4 컨텍스트와 DI

### 인터페이스를 사용하지 않는 DI

- **인터페이스가 없다는 것은 매우 긴밀한 관계를 가지고 강하게 결합되어 있다는 의미**
- 위의 경우 굳이 인터페이스를 두지 말고 강력한 결합을 가진 관계를 허용하면서 **스프링 빈으로 등록해서 DI가 되도록 만들어도 좋다**
    - 왜 스프링 빈으로 등록해야 하는가?
        - 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문
        - 다른 빈에 의존하고 있기 때문 ⇒ DI를 위해서 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록되어야 함
    - 장점: 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러남
    - 단점: DI의 근본적인 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 직접 노출
- **코드를 이용한 수동 DI**
    - 인터페이스를 두지 않아도 될 만큼 긴밀한 관계를 갖는 클래스를 어색하게 따로 빈으로 분리하지 않고 내부에서 직접 만들어 사용하면서도 다른 오브젝트에 대한 DI를 적용 가능하다
    - 한 오브젝트의 수정자 메소드에서 다른 오브젝트를 초기화하고 코드를 이용해 DI하는 것은 스프링에서도 종종 사용 되는 기법
    - 장점: 필요에 따라 내부에서 은밀히 DI를 수행하고 그 전략을 외부에 감출 수 있음
    - 단점: 싱글톤으로 만들 수 없음, 부가적인 코드가 필요
- 차라리 인터페이스를 만들어서 평범한 DI 구조로 만드는 게 나을 수도

## 3.5 템플릿과 콜백

템플릿: 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀

콜백: 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트, 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용

**템플릿/콜백 패턴: DI 방식의 전략 패턴의 기본구조에 익명내부클래스를 활용한 방식**

### 템플릿/콜백 특징

- 단일 메소드 인터페이스 사용
- 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달 받음
- 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조
- 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용
- 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스 이용

## 3.6 스프링의 JdbcTemplate

- 스프링은 JDBC 코드 작성을 위해 JdbcTemplate을 기반으로 하는 다양한 템플리과 콜백을 제공한다
- 네거티브 테스트를 먼저 하는 습관을 들이자!