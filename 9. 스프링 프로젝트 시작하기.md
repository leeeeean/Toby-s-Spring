# 9장. 스프링 프로젝트 시작하기

## 9.1 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션

#### 클라이언트와 백엔드 시스템

* 스프링 애플리케이션의 기본구조 : DB를 사용하는 웹 애플리케이션
  클라이언트가 웹 브라우져이고 백엔드 시스템이 DB인 구성
  그 외에도 다양한 클라이언트와 백엔드가 가능
  * 클라이언트
    웹 브라우져/HTML, RIA/Flex, X인터넷, .NET/Mobile/독립형, 엔터프라이즈 시스템
  * 백엔드
    데이터베이스, 메시징/메일 서버, 레거시 시스템, 엔터프라이즈 시스템

#### 애플리케이션 서버

##### JavaEE 표준을 따르는 애플리케이션 서버

* 경량급 WAS/서블릿 컨테이너
  * 톰캣, 제타 같은 가뱌운 서블릿 컨테이너로 충분
    리소스 커넥터나 분산 서비스 등을 사용하지 않는다면
  * 선언전 트랜잭션, 선언적 보안, DB 연결 풀링, 리모팅, 웹 서비스, 분산/글로벌 트랜잭션 까지 가능
* WAS
  * 고도의 안정성과 안정적인 리소스 관리, 레거시 시스템의 연동 등의 장점이 존재
  * 관리기능이나 모니터링 기능이 뛰어남
    여러대의 서버를 관리할 때 유용
  * 스프링과 완벽 호환
* 스프링은 WAS 사용을 권장

##### 스프링 소스 tcServer

* 경량급 애플리케이션 서버
* 고급 서버 관리 기능, 배포 기능, 진단 기능, 기술 지원 등의 장점
* 유료 라이선스

#### 스프링 애플리케이션 배포 단위

##### 독립 웹 모듈

* war로 패키징
* 톰캣 등의 서블릿 애플리케이션 사용 시 유일한 방법
* WAS 도 동일

##### 엔터프라이즈 애플리케이션

* ear 확장자를 가진 엔터프라이즈 애플리케이션으러 배포
* EJB 모듈을 사용하거나 EJB에서 스프링을 이용하는 경우 둘을 통합해야 함
* 하나 이상의 웹 모듈과 별도로 분리된 공유 가능한
  스프링 컨텍스트를 엠터프라이즈 애플리케이션으로 묶는 경우

##### 백그라운드 서비스 모듈

* rar 패키징
* 리소스 커넥터를 만들어 배포할 때 사용
* 서버 내에서 백그라운드 서비스처럼 동작하는 경우



## 개발도구와 환경

#### JavaSE와 JavaEE

##### JavaSE/JDK

* Spring 3.0은 JavaSE 5 버전을 기준으로 작성, JDK 5 이상 사용 필요
* JDBC 4.0 을 사용하려면 JDK 6 을 사용해야 함

##### JavaEE/J2EE

* 스프링 3.0이 사용될 자바 엔터프라이즈 플랫폼은 J2EE 1.4 혹은 JavaEE 5.0 필요

#### IDE

* 자바 개발 도구와 XML 편집기만 있으면 개발 가능
* 요즘은 통합개발환경을 사용 - InteliJ

#### SpringSource Tool Suite

* 스프링소스가 만들어서 제공하는 IDE
* 플러그인 조합이 완료되어 있는 툴

#### SpringIDE 플러그인

* 스프링 개발에 유용한 기능 제공
  * 스프링 프로젝트와 설정파일 생성 위저드
  * 스프링의 XML 설정파일 에디터
  * 빈의 의존관계 그래프
  * 네임스페이스 관리

##### 빈 클래스 이름 자동완성

* bean 태그의 class 애트리뷰트를 입력할 때 클래스 이름에 대힌 자동완성 지원
* 빈의 프로퍼티 등록시 자동 완성 지원

##### 빈 설정 오류검증 기능

* 빈 설정 내용을 작업하다가 존재하지 않는 클래스 이름을 넣거나
  잘못된 프로퍼티 이름을 지정하명 바로 오류마크를 보여줌

##### 프로젝트 생성, 설정파일 생성, 빈 등록 위저드

* XML 설정파일 생성 위저드는 스키마 선언부를 손쉽게 추가하거나 수정할 수 있게 함

##### 빈 의존관계 그래프

* 각 빈이 서로 어떻게 참조하고 있는지, 어떤 프로퍼티를 갖고 있는지 한눈에 볼수 있음

##### AOP 적용대상 표시

* XML 설정파일 편집기와 AJDT라는 AspectJ 개발 플러그인을 통해서
  포인트 컷이 적용되는 대상 빈을 설정파일 안에서 한눈에 확인 가능

#### STS 플러그인

* 스프링 애플리케이션의 서버 배치와 같은 추가 기능 제공
* 대시보드 기능 제공
* 지식베이스 검색 기능 제공

#### 기타 플러그인

##### M2Eclipse

* Maven을 지원하는 이클립스 플러그인

##### AJDT 

* AspectJ Develpment Tool
* AspectJ AOP를 이용한 개발을 지원하는 툴

##### VMCI 

* VMWare 사버 또는 워크스테이션과의 연동을 지원하는 플러그인

##### 이클립스 표준 플러그인

* 웹 개발을 지원하는 WTP, EMP, Mylyn, DSDP



### 라이브러리 관리와 빌드 툴

#### 라이브러리 관리의 어려움 

* 사용하는 라이브러리가 매우 많음
* 사용하지 않는 라이브러리도 매우 많음
* 라이브러리의 여러 버젼도 문제
  복잡한 의존관계 속에서 같은 라이브러리의 다른 버전이 동시에 필요할 수도 있음
  버전끼리 호환이 안되는 경우 문제가 됨
* 해결방법: 재패키징 -> jarjar

#### 라이브러리 선정 

스프링으로 만드는 애플리케이션에서 정확히 어떤 기능이 필요한지 정리
각 기능을 지원하는 기술이 여러가지 종류가 있는 경우 그중 어떤 것을 사용할 지도 결정

##### 스프링 모듈 

* 스프링에는 총 20개의 모듈이 있음
* 일부는 필수 모듈, 일부는 아키텍처와 사용기술에 따라 선택적 적용 가능

##### 라이브러리

* 부록 참고
* 시행착오

#### 빌드 툴과 라이브러리 관리 

빌드 툴 : Maven, ANT, Gradle

* IDE의 자동 빌드 외의 환경에서도 일관된 빌드가 필요
  * IDE + 환경에 독립적인 빌드 툴

Maven

* 개발과정에서 필요한 빌드, 테스트, 배치, 문서화, 리포팅 등의 
  다양한 작업을 지원하는 종합 프로젝트 관리 툴
* POM 으로 불리는 프로젝트 모델 정보를 이용
* 선언적
* Maven POM은 의존 라이브러리를 선어해두기만 하면 
  원격 서버에서 이를 자동으로 다운받아서 사용가능하게 해줌
* 전이적 의존 라이브러리 추적 기능
  * 하나의 라이브러리를 지정하면 이 라이브러리에 필요한 다른 라이브러리까지 함께 다운로드

스프링의 모든 모듈을 POM 정보를 가지고 있다
그렇다고 라이브러리에 대한 문제들이 사라지지는 않는다 개발자가 계속 관리해야함

Maven은 라이브러리의 효과적인 관리 측면에서 필요하다

#### 스프링 모듈의 두 가지 이름과 리포지토리

core모듈 두 가지 --> 같은 모듈

* spring-core-3.0.7.RELEASE.jar
  * 메이븐 명명 규칙
* org.springframework.core-.3.0.7.RELEASE.jar
  * OSGi 명명 규칙

## 9.3 애플리케이션 아키텍쳐

### 계층형 아키텍쳐

#### 아키텍쳐와 IoC

* 계층형 아키텍쳐 (멀티 티어 아키텍쳐) : 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것
* 웹 기반의 엔터프라이즈 애플리케이션 → 3계층 애플리케이션

#### 3계층 아키텍쳐와 수직 계층

* 데이터 엑세스 계층
  * DB나 레거지 시스템과 연동하는 인터페이스 역할
    → DAO 계층, EIS 계층
  * DAO 패턴을 보편적으로 사용
  * 외부 시스템을 호출해서 서비스를 이용하는 기반 계층을 따로 분리하기도 함
  * 다시 세분화 한 경우는 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부름
    * 역할에 따라 가로 배열
    * 같은 책임을 가졌지만 추상화 레벨에 따라 구분하는 경우 세로 배열
  * 새로운 계층 추가는 신중하게
* 서비스 계층
  * 비즈니스 로직을 담고 있는 계층
    → 매니저 계층, 비즈니스 로직 계층
  * DAO 계층을 호출하고 이를 활용해서 만들어짐
  * 수직 계층이 필요 없음
  * 기반 서비스 계층은 3계층 모두 접근이 가능한 경우 혹은 서비스 계층을 통해서 접근하는 경우가 존재
  * 스케쥴링의 경우 기반 서비스 계층에서 서비스 계층에 접근하게 됨
  * 서비스 계층이 가장 중요
* 프레젠테이션 계층
  * UI를 만들어내고 그 흐룸을 관리하는 역할
    → 웹 계층, UI 계층, MVC 계층
  * 다양한 기술과 프레임워크의 조합이 가능
  * HTTP 프로토콜을 사용하는 서블릿이 바탕
  * 클라이언트까지 범위가 확장될 수 있음

#### 계층형 아키텍쳐 설계의 원칙

* 오브젝트와 그 관계에서 적용했던 대부분의 객체지향 설계의 원칙은 
  아키텍쳐 레벨의 계층과 그 관계에도 동일하게 적용할 수 있다

* 각 계층은 응직도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다
* 각 계층은 자신의 계층의 책임에만 충실해야 한다
* 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다
* 어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설게해야 한다
  * 계층 사이의 호출은 인터페이스를 통해
* 스프링의 DI는 오브젝트 사이의 관계를 다룬다
  * DI는 계층을 구분해 주지 않는다
  * 다른 계층에 함부로 DI를 가져다 쓰지 않아야 한다
  * 중간 계층을 건너 뛰어서 빈을 직접 DI 하지 않는다

### 애플리케이션 정보 아키텍쳐

애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 
아키텍처를 결정할 때 매우 중요한 기준이 된다

* 정보를 단순이 데이터로 다루는 경우

* 정보를 오브젝트로 다루는 경우

#### DB/SQL 중심의 로직 구현 방식

데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 것

* 개발이 쉽다
* 변화에 취약하다
* SQL이나 저장 프로시져에 담긴 로직은 테스트 하기 힘들다

#### 거대한 서비스 계층 방식

DB에 부하가 걸리지 않도로 저장 프로시저의 사용을 자제하고 
복잡한 SQL을 피하면서 주요 로직은 서비스 계층의 코드에서 처리하도록 만든다

비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다

장점

* 자바 언어의 장점을 활용해 로직을 구현
* 테스트 수월
* 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용 가능

하지만 여전히 계층간의 결합도는 높음

* SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어짐

단점

* 객체지향적 설계를 적용하기 힘듬
* 개발자 개개인의 코딩 습관이나 실력에 따라서 다른 스타일의 코드가 나옴
* 스파게티 코드의 위험

### 오브젝트 중심 아키텍쳐

도메인 모델을 반영하는 오브젝트 구조를 만들어두고 
그것을 각 계층 사이에서 정보를 전송하는 데 사용

오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 게층 사이에 전달하게 만드는 것

#### 데이터와 오브젝트

데이터 중심

* DAO에서 받아온 타입을 봐서는 안에 담긴 내용이 어떤 것인지 알 수 없음
* DAO에서 SQL을 변경하거나 필드 개수나 순서, 이름을 바꾼다면 
  서비스 계층과 프레젠테이션 계층의 코드도 같이 변경되어야 함
* 관계에 대한 정보가 없음
* DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존

오브젝트 중심

* 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서
  만들어진 오브젝트 안에 담김
* 도메인 모델은 전 계층에서 동일한 의미를 갖음
  오브젝트로 전 계층에서 일관된 구조를 유지한 채롤 사용 가능
* DB 테이블의의 정보와 그 관게를 유지한 채로 오브젝트를 만들어서 사용

#### 도메인 오브젝트 사용의 문제점

* 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해
* 오브젝트의 모든 필드 정보를 채워서 전단하는 것은 낭비일 가능성이 있음
* 필요 없는 오브젝트까지 다 조회해서 오브젝트로 만들어서 가져오는 낭비
* 결합도가 높아지는 문제가 발생할 수 있음

해결법

* 지연된 로딩
  * 최소의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 
    다이내믹하게 DB에서 다시 읽어오는 방법
  * 오브젝트 맵핑 기술을 사용하기 - 지연된 로딩 지원

#### 빈약한 도메인 오브젝트 방식

→ 도메인 오브젝트에 정보만 담겨있고, 정보를 활용하는 아무런 기능도 갖고있지 않는 경우

빈약한 도메인 오브젝트에서의 도메인 비즈니스 로직은 서비스 계층에 존재

거대 서비스 계층 방식의 하나

로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉬움

유용한 아키텍쳐인 것은 맞음

#### 풍성한 도메인 오브젝트 방식 (= 영리한 도메인 오브젝트)

→  어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있고, 
이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 
서비스 계층의 비즈니스 로직에서 재사용하게 만듬

빈약한 도메인 오브젝트 방식보다 훨씬 간결하고 객체지향적

*도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근 할 수 없기 때문에 서비스 계층이 필요하다

도메인 오브젝트는 빈이 아님

#### 도메인 계층 방식

→ 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 방식

특징

1. 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다
2. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용이 가능하다
   * 여전히 빈이 아니다
   * 하지만 스프링이 관리하지 않는 오브젝트에도 DI가 가능하다

AOP 필요성

* AspectJ의 AOP를 사용하면 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능을 적용할 수 있다

서비스 계층의 역할

* 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행해야 하는 경우, 
  서비스 계층에서 도메인 계층과 협력을 통해 진행
* 도메인 계층을 거치지 않고 바로 데이터 액세스 계층으로부터 정보를 가져와 
  클라이언트에 제공해야 하는 경우
* 트랜잭션 경계를 설정
* 특정 도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 하는 
  기반 서비스를 이용해야 하는 작업을 위해서

도메인 계층 방식에서 고려해야 하는 사항

* 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할 것인가?

선택할 수 있는 방법

1. 여전히 모든 계층에서 도메인 오브젝트를 사용한다
   * 강력한 규약
   * AspectJ
2. 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 한다
   * DTO
   * AOP

#### DTO와 리포트 쿼리

DB쿼리의 실행결과를 담는 리포트 쿼리 → 리포트를 출력하기 위해 생성하는 쿼리

​	여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 결과를 생성하는 쿼리

리포트 쿼리 결과를 적절하게 담을 도메인 오브젝트를 찾을 수 없음
DTO라고 불리는 단순한 자바빈이나 맵에 담아서 전달 해야 함

### 스프링 애플리케이션을 위한 아키텍쳐 설계

#### 상태 관리와 빈 스코프

스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장한다
웹의 생리에 가장 잘 들어맞고 개발하기 쉽기 때문이다
또, 서버를 여러대로 확장하기가 매우 쉽다

스프링을 이용해서 상태 유지 스타일의 애플리케이션을 만들 수 있다

스츠링에서는 싱글톤 외에도 다른 스코프를 갖는 빈을 간단히 만들 수 있다

#### 서드파티 프레임워크 , 라이브러리 적용

스프링이 지원하는 기술이란?

1. 해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다
   * 프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원해주는 것
   * 빈으로 등록해서 바로 사용할 수 있는 구조로 만들어 있지 않은 경우 팩토리 빈을 도입해야 함
2. 스프링의 서비스 추상화가 적용됐다
   * 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해줌
   * 추상 서비스 인터페이스를 구현해서 각 기술과 연동하게 해주는 어댑터 클래스가 필요
   * 서비스 추상화 인터페이스를 구현한 클래스들은 모두 스프링 빈으로 등롣되도록 만들어짐
3. 스프링이 지지하는 프로그래밍 모델을 적용했다
4. 템플릿/콜백이 지원된다
   * 템플릿 클래스는 빈으로 등록해서 필요한 빈에서 DI 받아 사용할 수 있다

##### 스프링이 어떤 기술을 지원한다는 건, 결국 스프링이 지지하는 개발철학과 프로그래밍 모델을 따르면서 해당 기술을 사용할 수 있다는 의미다



